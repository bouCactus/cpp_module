#include <string>#include <iostream>#include <sstream>#include <fstream>#include <map>const char* ws = " \t\n\r\f\v";// trim from end of string (right)inline std::string& rtrim(std::string& s, const char* t = ws){    s.erase(s.find_last_not_of(t) + 1);    return s;}// trim from beginning of string (left)inline std::string& ltrim(std::string& s, const char* t = ws){    s.erase(0, s.find_first_not_of(t));    return s;}// trim from both ends of string (right then left)inline std::string& trim(std::string& s, const char* t = ws){    return ltrim(rtrim(s, t), t);}std::pair<std::string, std::string> split(std::string s, char del){    std::stringstream ss(s);    std::string word;    std::string tokens[2];    for (int i = 0; i < 2 && std::getline(ss, word, del); ++i) {        tokens[i] = trim(word);    }    return (std::make_pair(tokens[0],tokens[1]));}bool isValidDate(const std::string& dateStr) {    try {      if (dateStr.size() != 10) {  // Check length        throw std::invalid_argument("Error: bad input => " + dateStr);      }        int year = std::stoi(dateStr.substr(0, 4));          int month = std::stoi(dateStr.substr(5, 2));         int day = std::stoi(dateStr.substr(8, 2));          if (year < 1900 || year > 9999	    || month < 1 || month > 12 || day < 1 || day > 31) {	  throw std::invalid_argument("Error: bad input => " + dateStr);        }    } catch (const std::invalid_argument& e) {      std::cerr << e.what() << std::endl;        return false;    }    return true;}bool isNumeric(const std::string& str) {  size_t n_nm, n_pt;  std::size_t char_pos(0);  for (n_nm = 0, n_pt = 0; std::isdigit(str[char_pos]) || str[char_pos] == '.'; ++char_pos) {    str[char_pos] == '.' ? ++n_pt : ++n_nm;  }  if (n_pt>1 || n_nm<1 || (n_nm + n_pt) != str.length()) // no more than one point, at least one digit    return false;  return (true);}bool isValidNumber(const std::pair<std::string, std::string>& token){  try{    if (token.second.empty() || !isNumeric(token.second))      throw std::invalid_argument("Error: bad input => " + token.first);  }catch(const std::invalid_argument& e){    std::cerr << e.what() << std::endl;    return (false);  }  return (true);}bool isValidNumberInput(const std::pair<std::string, std::string>& token){  try{    float num = std::stof(token.second);    if (num > 1000){      throw std::invalid_argument("Error: too large a number.");    }    if (num < 0)      throw std::invalid_argument("Error: not a positive number.");  }catch(const std::invalid_argument& e){    std::cerr << e.what() << std::endl;    return (false);  }  return (true);}int isValidToken(const std::pair<std::string, std::string>& token){  return (isValidDate(token.first) && isValidNumber(token));}std::map<std::string, float>::iteratorget_date_before(std::map<std::string, float>& m, const std::string& date) {  std::map<std::string, float>::iterator it = m.lower_bound(date);  if (it == m.begin()) {    return m.begin();  } else {    --it;    return it;  }}void caluclateBtcValue(std::map<std::string, float>&m,std::pair<std::string, float>token){  std::map<std::string, float>::iterator it;  it = m.find(token.first);  if (it == m.end())    it = get_date_before(m, token.first);  std::cout << token.first << " => "	    << token.second	    << " = "	    << it->second * token.second	    <<std::endl;}void parseDataFile(std::ifstream &file, std::map<std::string, float>& m){  std::pair<std::string, std::string>token;  std::string line;  while  (getline(file, line)){    token = split(line, ',');    if(!isValidToken(token)){      std::cerr << "Error: database: invalid token format\n";      std::exit(1);    }    m.insert(std::make_pair(token.first, std::stof(token.second)));  }}void parseInputFile(std::ifstream& file, std::map<std::string, float>&m){  std::pair<std::string,std::string>token;  std::string line;  while (getline(file,line)){    token = split(line, '|');    std::cerr << "token: " << "[ " << token.first << "," << token.second << " ]" << std::endl;    if (isValidToken(token) && isValidNumberInput(token)){      caluclateBtcValue(m, std::make_pair(token.first,std::stof(token.second)));    }  }}int main(int argc, char *argv[]){  std::ifstream inputFile;  std::ifstream data;  std::map<std::string, float>m;  if (argc != 2){    std::cout << "Error: could not open file." << std::endl;    return (1);  }  inputFile.open(argv[1], std::ios::in);    if (!inputFile.is_open()){    std::cout << "Error: could not open file." << std::endl;    return (1);  }  data.open("./data.csv", std::ios::in);  if (!data.is_open()){    std::cout << "Error: could not read from data" << std::endl;    return (1);  }  // parseDataFile(data, m);  parseInputFile(inputFile, m);       inputFile.close();  return (0);}